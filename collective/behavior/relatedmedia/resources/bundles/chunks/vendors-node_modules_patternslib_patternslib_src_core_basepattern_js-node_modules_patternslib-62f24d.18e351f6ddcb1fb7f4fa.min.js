"use strict";
(self["webpackChunkrelatedmedia"] = self["webpackChunkrelatedmedia"] || []).push([["vendors-node_modules_patternslib_patternslib_src_core_basepattern_js-node_modules_patternslib-62f24d"],{

/***/ "./node_modules/@patternslib/patternslib/src/core/basepattern.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@patternslib/patternslib/src/core/basepattern.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BasePattern: () => (/* binding */ BasePattern),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./events */ "./node_modules/@patternslib/patternslib/src/core/events.js");
/* harmony import */ var _logging__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./logging */ "./node_modules/@patternslib/patternslib/src/core/logging.js");
/**
 * A Base pattern for creating scoped patterns.
 *
 * Each instance of a pattern has its own local scope.
 * A new instance is created for each DOM element on which a pattern applies.
 *
 * For usage, see basepattern.md
 */


const log = _logging__WEBPACK_IMPORTED_MODULE_1__["default"].getLogger("basepattern");
class BasePattern {
  static name; // name of pattern used in Registry.
  static trigger; // A CSS selector to match elements that should trigger the pattern instantiation.
  static parser; // Options parser.

  // Parser options
  parser_group_options = true;
  parser_multiple = undefined;
  parser_inherit = true;
  constructor(el, options = {}) {
    // Make static variables available on instance.
    this.name = this.constructor.name;
    this.trigger = this.constructor.trigger;
    this.parser = this.constructor.parser;
    if (!el) {
      log.warn(`No element given to pattern ${this.name}.`);
      return;
    }
    if (el.jquery) {
      el = el[0];
    }
    this.el = el;

    // Notify pre-init
    this.el.dispatchEvent(new Event(`pre-init.${this.name}.patterns`, {
      bubbles: true,
      cancelable: true
    }));

    // Initialize asynchronously.
    //
    // 1) We need to call the concrete implementation of ``init``, but the
    //    inheritance chain is not yet set up and ``init`` not available.
    //
    // 2) We want to wait for the init() to successfuly finish and fire an
    //    event then.
    //    But the constructer cannot not return a Promise, thus not be
    //    asynchronous but only return itself.
    //
    // Both limitations are gone in next tick.
    //
    window.setTimeout(async () => {
      var _this$parser;
      if (typeof this.el[`pattern-${this.name}`] !== "undefined") {
        // Do not reinstantiate
        log.debug(`Not reinstatiating the pattern ${this.name}.`, this.el);

        // Notify that not instantiated
        this.el.dispatchEvent(new Event(`not-init.${this.name}.patterns`, {
          bubbles: true,
          cancelable: false
        }));
        return;
      }

      // Create the options object by parsing the element and using the
      // optional options as default.
      this.options = ((_this$parser = this.parser) === null || _this$parser === void 0 ? void 0 : _this$parser.parse(this.el, options, this.parser_multiple, this.parser_inherit, this.parser_group_options)) ?? options;

      // Store pattern instance on element
      this.el[`pattern-${this.name}`] = this;

      // Initialize the pattern
      await this.init();

      // Notify that now ready
      this.el.dispatchEvent(new Event(`init.${this.name}.patterns`, {
        bubbles: true,
        cancelable: true
      }));
    }, 0);
  }
  async init() {
    // Extend this method in your pattern.
  }

  /**
   * Listen to an event on the element only once.
   *
   * @param {string} event_name - Name of the event to listen to.
   * @param {function} callback - Callback to call when the event is thrown.
   */
  one(event_name, event_callback) {
    _events__WEBPACK_IMPORTED_MODULE_0__["default"].add_event_listener(this.el, `${event_name}.${this.name}.patterns`, `basepattern-one--${event_name}.${this.name}.patterns`, event_callback, {
      once: true
    });
  }

  /**
   * Destroy/remove/unload the pattern from the element.
   */
  destroy() {
    delete this.el[`pattern-${this.name}`];
  }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BasePattern);


/***/ }),

/***/ "./node_modules/@patternslib/patternslib/src/core/dom.js":
/*!***************************************************************!*\
  !*** ./node_modules/@patternslib/patternslib/src/core/dom.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./events */ "./node_modules/@patternslib/patternslib/src/core/events.js");
/* harmony import */ var _logging__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./logging */ "./node_modules/@patternslib/patternslib/src/core/logging.js");
/* Utilities for DOM traversal or navigation */


const logger = _logging__WEBPACK_IMPORTED_MODULE_1__["default"].getLogger("core dom");
const DATA_PREFIX = "__patternslib__data_prefix__";
const DATA_STYLE_DISPLAY = "__patternslib__style__display";

/**
 * Return an array of DOM nodes.
 *
 * @param {Node|NodeList|jQuery} nodes - The DOM node to start the search from.
 *
 * @returns {Array} - An array of DOM nodes.
 */
const toNodeArray = nodes => {
  if (nodes.jquery || nodes instanceof NodeList) {
    // jQuery or document.querySelectorAll
    nodes = [...nodes];
  } else if (nodes instanceof Array === false) {
    nodes = [nodes];
  }
  return nodes;
};

/**
 * Like querySelectorAll but including the element where it starts from.
 * Returns an Array, not a NodeList
 *
 * @param {Node} el - The DOM node to start the search from.
 *
 * @returns {Array} - The DOM nodes found.
 */
const querySelectorAllAndMe = (el, selector) => {
  if (!el) {
    return [];
  }
  const all = [...el.querySelectorAll(selector)];
  if (el.matches(selector)) {
    all.unshift(el); // start element should be first.
  }
  return all;
};

/**
 * Wrap a element with a wrapper element.
 *
 * The element to be wrapped will be moved into the wrapper element and the
 * wrapper element is placed just before the old element was.
 *
 * @param {Node} el - The DOM node to wrap.
 * @param {Node} wrapper - The wrapper element.
 */
const wrap = (el, wrapper) => {
  // See: https://stackoverflow.com/a/13169465/1337474
  el.parentNode.insertBefore(wrapper, el);
  wrapper.appendChild(el);
};

/**
 * Hides the element with ``display: none`` and stores the current display value.
 *
 * @param {Node} el - The DOM node to hide.
 */
const hide = el => {
  if (el.style.display === "none") {
    // Nothing to do.
    return;
  }
  if (el.style.display) {
    el[DATA_STYLE_DISPLAY] = el.style.display;
  }
  el.style.display = "none";
};

/**
 * Shows element by removing ``display: none`` and restoring the display value
 * to whatever it was before.
 *
 * @param {Node} el - The DOM node to show.
 */
const show = el => {
  const val = el[DATA_STYLE_DISPLAY] || null;
  el.style.display = val;
  delete el[DATA_STYLE_DISPLAY];
};

/**
 * Test, if a element is visible or not.
 *
 * @param {Node} el - The DOM node to test.
 * @returns {Boolean} - True if the element is visible.
 */
const is_visible = el => {
  // Check, if element is visible in DOM.
  // https://stackoverflow.com/a/19808107/1337474
  return el.offsetWidth > 0 && el.offsetHeight > 0;
};

/**
 * Test, if a element is a input-type element.
 *
 * This is taken from Sizzle/jQuery at:
 * https://github.com/jquery/sizzle/blob/f2a2412e5e8a5d9edf168ae3b6633ac8e6bd9f2e/src/sizzle.js#L139
 * https://github.com/jquery/sizzle/blob/f2a2412e5e8a5d9edf168ae3b6633ac8e6bd9f2e/src/sizzle.js#L1773
 *
 * @param {Node} el - The DOM node to test.
 * @returns {Boolean} - True if the element is a input-type element.
 */
const is_input = el => {
  const re_input = /^(?:input|select|textarea|button)$/i;
  return re_input.test(el.nodeName);
};

/**
 * Return all direct parents of ``el`` matching ``selector``.
 * This matches against all parents but not the element itself.
 * The order of elements is from the search starting point up to higher
 * DOM levels.
 *
 * @param {Node} el - The DOM node to start the search from.
 * @param {String} selector - CSS selector to match against.
 * @returns {Array} - List of matching DOM nodes.
 */
const find_parents = (el, selector) => {
  const ret = [];
  let parent = el;
  while (parent) {
    var _parent$parentNode, _parent$parentNode$cl, _parent$parentNode2;
    parent = (_parent$parentNode = parent.parentNode) === null || _parent$parentNode === void 0 || (_parent$parentNode$cl = (_parent$parentNode2 = _parent$parentNode).closest) === null || _parent$parentNode$cl === void 0 ? void 0 : _parent$parentNode$cl.call(_parent$parentNode2, selector);
    if (parent) ret.push(parent);
  }
  return ret;
};

/**
 * Find an element in the whole DOM tree if the selector is an ID selector,
 * otherwise use the given element as the starting point.
 *
 * @param {Node} el - The DOM node to start the search from.
 * @param {String} selector - The CSS selector to search for.
 *
 * @returns {NodeList} - The DOM nodes found.
 *
 */
const find_scoped = (el, selector) => {
  // If the selector starts with an object id do a global search,
  // otherwise do a local search.
  return (selector.indexOf("#") === 0 ? document : el).querySelectorAll(selector);
};

/**
 * Return all HTMLElement parents of el, starting from the direct parent of el.
 * The document itself is excluded because it's not a real DOM node.
 *
 * @param {Node} el - The DOM node to start the search from.
 *
 * @returns {Array} - The DOM nodes found.
 */
const get_parents = el => {
  // Return all HTMLElement parents of el, starting from the direct parent of el.
  const parents = [];
  let parent = el === null || el === void 0 ? void 0 : el.parentNode;
  while (parent) {
    var _parent;
    parents.push(parent);
    parent = (_parent = parent) === null || _parent === void 0 ? void 0 : _parent.parentNode;
    parent = parent instanceof HTMLElement ? parent : null;
  }
  return parents;
};

/**
 * Return the value of the first attribute found in the list of parents.
 *
 * @param {Node} el - The DOM element to start the acquisition search for the given attribute.
 * @param {string} attribute - Name of the attribute to search for.
 * @param {Boolean} include_empty - Also return empty values.
 * @param {Boolean} include_all - Return a list of attribute values found in all parents.
 *
 * @returns {*} - Returns the value of the searched attribute or a list of all attributes.
 */
const acquire_attribute = (el, attribute, include_empty = false, include_all = false) => {
  let _el = el;
  const ret = []; // array for ``include_all`` mode.
  while (_el) {
    const val = _el.getAttribute(attribute);
    if (val || include_empty && val === "") {
      if (!include_all) {
        return val;
      }
      ret.push(val);
    }
    _el = _el.parentElement;
  }
  if (include_all) {
    return ret;
  }
};

/**
 * Return a DocumentFragment from a given string.
 *
 * @param {String} string - The HTML structure as a string.
 *
 * @returns {DocumentFragment} - The DOM nodes as a DocumentFragment.
 */
const create_from_string = string => {
  // See: https://davidwalsh.name/convert-html-stings-dom-nodes
  return document.createRange().createContextualFragment(string.trim());
};

/**
 * Return a CSS property value for a given DOM node.
 * For length-values, relative values are converted to pixels.
 * Optionally parse as pixels, if applicable.
 *
 * Note: The element must be attached to the body to make CSS caluclations work.
 *
 * @param {Node} el - DOM node.
 * @param {String} property - CSS property to query on DOM node.
 * @param {Boolean} [as_pixels=false] - Convert value to pixels, if applicable.
 * @param {Boolean} [as_float=false] - Convert value to float, if applicable.
 *
 * @returns {(String|Number)} - The CSS value to return.
 */
function get_css_value(el, property, as_pixels = false, as_float = false) {
  let value = window.getComputedStyle(el).getPropertyValue(property);
  if (as_pixels || as_float) {
    value = parseFloat(value) || 0.0;
  }
  if (as_pixels && !as_float) {
    value = parseInt(Math.round(value), 10);
  }
  return value;
}

/**
 * Find a scrollable element up in the DOM tree.
 *
 * Note: Setting the ``overflow`` shorthand property also sets the individual overflow-y and overflow-y properties.
 *
 * @param {Node} el - The DOM element to start the search on.
 * @param {String} [direction=] - Not given: Search for any scrollable element up in the DOM tree.
 *                                ``x``: Search for a horizontally scrollable element.
 *                                ``y``: Search for a vertically scrollable element.
 * @param {(Node|null)} [fallback=document.body] - Fallback, if no scroll container can be found.
 *                                                     The default is to use document.body.
 *
 * @returns {Node} - Return the first scrollable element.
 *                   If no other element could be found, document.body would be returned.
 */
const find_scroll_container = (el, direction, fallback = document.body) => {
  while (el && el !== document.body) {
    if (!direction || direction === "y") {
      let overflow_y = get_css_value(el, "overflow-y");
      if (["auto", "scroll"].includes(overflow_y)) {
        return el;
      }
    }
    if (!direction || direction === "x") {
      let overflow_x = get_css_value(el, "overflow-x");
      if (["auto", "scroll"].includes(overflow_x)) {
        return el;
      }
    }
    el = el.parentElement;
  }
  return fallback;
};

/**
 * Get the horizontal scroll position.
 *
 * @param {Node} scroll_reference - The element to get the scroll position from.
 *
 * @returns {number} The horizontal scroll position.
 */
const get_scroll_x = scroll_reference => {
  // scroll_listener == window: window.scrollX
  // scroll_listener == html: html.scrollLeft == window.scrollX
  // scroll_listener == DOM node: node.scrollLeft
  return typeof scroll_reference.scrollLeft !== "undefined" ? scroll_reference.scrollLeft : scroll_reference.scrollX;
};

/**
 * Get the vertical scroll position.
 *
 * @param {Node} scroll_reference - The element to get the scroll position from.
 *
 * @returns {number} The vertical scroll position.
 */
const get_scroll_y = scroll_reference => {
  // scroll_listener == window: window.scrollY
  // scroll_listener == html: html.scrollTop == window.scrollY
  // scroll_listener == DOM node: node.scrollTop
  return typeof scroll_reference.scrollTop !== "undefined" ? scroll_reference.scrollTop : scroll_reference.scrollY;
};

/**
 * Get the elements position relative to another element.
 *
 * @param {Node} el - The DOM element to get the position for.
 * @param {Node} [reference_el=document.body] - The DOM element to get the position relative to.
 *
 * @returns {{top: number, left: number}} - The position of the element relative to the other element.
 */
const get_relative_position = (el, reference_el = document.body) => {
  // Get the reference element to which against we calculate
  // the relative position of the target.
  // In case of a scroll container of window, we do not have
  // getBoundingClientRect method, so get the body instead.
  if (reference_el === window) {
    reference_el = document.body;
  }

  // Calculate absolute [¹] position difference between
  // scroll_container and scroll_target.
  // Substract the container's border from the scrolling
  // value, as this one isn't respected by
  // getBoundingClientRect [²] and would lead to covered
  // items [³].
  // ¹) so that it doesn't make a difference, if the element
  // is below or above the scrolling container. We just need
  // to know the absolute difference.
  // ²) Calculations are based from the viewport.
  // ³) See:
  //      https://docs.microsoft.com/en-us/previous-versions//hh781509(v=vs.85)
  //      https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect
  const left = Math.abs(el.getBoundingClientRect().left + reference_el.scrollLeft - reference_el.getBoundingClientRect().left - dom.get_css_value(reference_el, "border-left-width", true));
  const top = Math.abs(el.getBoundingClientRect().top + reference_el.scrollTop - reference_el.getBoundingClientRect().top - dom.get_css_value(reference_el, "border-top-width", true));
  return {
    top,
    left
  };
};

/**
 * Scroll to a given element.
 * The element will be scrolled to the top of the scroll container.
 *
 * @param {Node} el - The element which should be scrolled to.
 * @param {Node} scroll_container - The element which is scrollable.
 * @param {number} [offset=0] - Optional offset in pixels to stop scrolling before the target position. Can also be a negative number.
 * @param {string} [direction="top"] - The direction to scroll to. Can be either "top", "left" or "both".
 */
const scroll_to_element = (el, scroll_container, offset = 0, direction = "top") => {
  // Get the position of the element relative to the scroll container.
  const position = get_relative_position(el, scroll_container);
  const options = {
    behavior: "auto"
  };
  if (direction === "top" || direction === "both") {
    options.top = position.top - offset;
  }
  if (direction === "left" || direction === "both") {
    options.left = position.left - offset;
  }

  // Scroll to the target position.
  scroll_container.scrollTo(options);
};

/**
 * Scroll to the top of a scrolling container.
 *
 * @param {Node} [scroll_container = document.body] - The element which is scrollable.
 * @param {number} [offset=0] - Optional offset in pixels to stop scrolling before the target position. Can also be a negative number.
 */
const scroll_to_top = (scroll_container = document.body, offset = 0) => {
  // Just scroll up, period.
  scroll_container.scrollTo({
    top: 0 - offset,
    behavior: "auto"
  });
};

/**
 * Scroll to the bottom of a scrolling container.
 *
 * @param {Node} [scroll_container = document.body] - The element which is scrollable.
 * @param {number} [offset=0] - Optional offset in pixels to stop scrolling before the target position. Can also be a negative number.
 */
const scroll_to_bottom = (scroll_container = document.body, offset = 0) => {
  // Just scroll up, period.
  //
  const top = (scroll_container === window ? document.body : scroll_container).scrollHeight;
  scroll_container.scrollTo({
    top: top - offset,
    behavior: "auto"
  });
};

/**
 * Get data stored directly on the node instance.
 * We are using a prefix to make sure the data doesn't collide with other attributes.
 *
 * @param el {Node} - The DOM node from which we want to retrieve the data.
 * @param name {String} - The name of the variable. Note - this is stored on
 *                        the DOM node prefixed with the DATA_PREFIX.
 * @param default_value {Any} - Optional default value.
 * @returns {Any} - The value which is stored on the DOM node.
 */
const get_data = (el, name, default_value) => {
  return el[`${DATA_PREFIX}${name}`] || default_value;
};

/**
 * Set and store data directly on the node instance.
 * We are using a prefix to make sure the data doesn't collide with other attributes.
 *
 * @param el {Node} - The DOM node which we want to store the data on.
 * @param name {String} - The name of the variable. Note - this is stored on
 *                        the DOM node prefixed with the DATA_PREFIX.
 * @param value {Any} - The value we want to store on the DOM node.
 */
const set_data = (el, name, value) => {
  el[`${DATA_PREFIX}${name}`] = value;
};

/**
 * Delete a variable from the node instance.
 * We are using a prefix to make sure the data doesn't collide with other attributes.
 *
 * @param el {Node} - The DOM node which we want to delete the variable from.
 * @param name {String} - The name of the variable. Note - this is stored on
 *                        the DOM node prefixed with the DATA_PREFIX.
 */
const delete_data = (el, name) => {
  delete el[`${DATA_PREFIX}${name}`];
};

/**
 * Simple template engine, based on JS template literal
 *
 * NOTE: This uses eval and would break if Content-Security-Policy does not
 *       allow 'unsafe-eval'.
 *       Because of this CSR problem the use of this method is not recommended.
 *
 * Please note: You cannot pass a template literal as template_string.
 * JavaScript itself would try to expand it and would fail.
 *
 * See: https://stackoverflow.com/a/37217166/1337474
 *
 * @param {String} template_string - The template string as a JavaScript template literal.
 *                                   For each variable in the template you have to use ``this``.
 *                                   E.g. if you pass ``{message: "ok"}`` as template_variables, you can use it like so:
 *                                   `<h1>${this.message}</h1>`
 * @param {Object} template_variables - Object literal with all the variables which should be used in the template.
 *
 * @returns {String} - Returns the a string as template expanded with the template_variables.
 */
const template = (template_string, template_variables = {}) => {
  logger.warn("Using dom.template is not recommended due to a problem with Content-Security-Policy.");
  return new Function("return `" + template_string + "`;").call(template_variables);
};

/**
 * Get the visible ratio of an element compared to container.
 * If no container is given, the viewport is used.
 *
 * Note: currently only vertical ratio is supported.
 *
 * @param {Node} el - The element to get the visible ratio from.
 * @param {Node} [container] - The container to compare the element to.
 * @returns {number} - The visible ratio of the element.
 *                    0 means the element is not visible.
 *                    1 means the element is fully visible.
 */
const get_visible_ratio = (el, container) => {
  if (!el) {
    return 0;
  }
  const rect = el.getBoundingClientRect();
  const container_rect = container !== window ? container.getBoundingClientRect() : {
    top: 0,
    bottom: window.innerHeight
  };
  let visible_ratio = 0;
  if (rect.top < container_rect.bottom && rect.bottom > container_rect.top) {
    const rect_height = rect.bottom - rect.top;
    const visible_height = Math.min(rect.bottom, container_rect.bottom) - Math.max(rect.top, container_rect.top);
    visible_ratio = visible_height / rect_height;
  }
  return visible_ratio;
};

/**
 * Get an escaped CSS selector for a given id string.
 *
 * id selectors should - but don't have to - start with a letter.
 * If the id starts with a number or a dash, it should be escaped.
 * This method does that for you.
 *
 * Alse see:
 * - https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/id
 * - https://developer.mozilla.org/en-US/docs/Web/API/CSS/escape
 *
 * @param {String} id - The id to escape.
 *
 * @returns {String} - The escaped CSS selector.
 *
 * @example
 * escape_css_id_selector("#123"); // returns "#\\31 23""
 * escape_css_id_selector("#-123"); // returns "#-\\31 23"
 */
const escape_css_id = id => {
  return `#${CSS.escape(id.split("#")[1])}`;
};

/**
 * Get a universally unique id (uuid) for a DOM element.
 *
 * This method returns a uuid for the given element. On the first call it will
 * generate a uuid and store it on the element.
 *
 * @param {Node} el - The DOM node to get the uuid for.
 * @returns {String} - The uuid.
 */
const element_uuid = el => {
  if (!get_data(el, "uuid", false)) {
    let uuid;
    if (window.crypto.randomUUID) {
      // Create a real UUID
      // window.crypto.randomUUID does only exist in browsers with secure
      // context.
      // See: https://developer.mozilla.org/en-US/docs/Web/API/Crypto/randomUUID
      uuid = window.crypto.randomUUID();
    } else {
      // Create a sufficiently unique ID
      const array = new Uint32Array(4);
      uuid = window.crypto.getRandomValues(array).join("");
    }
    set_data(el, "uuid", uuid);
  }
  return get_data(el, "uuid");
};

/**
 * Find a related form element.
 *
 * @param {Node} el - The DOM node to start the search from.
 * @returns {Node} - The closest form element.
 *
 * @example
 * find_form(document.querySelector("input"));
 */
const find_form = el => {
  var _el$querySelector;
  // Prefer input.form which allows for input outside form elements and fall
  // back to search for a parent form.
  const form = el.closest(".pat-subform") ||
  // Special Patternslib subform concept has precedence.
  el.form || ((_el$querySelector = el.querySelector("input, select, textarea, button")) === null || _el$querySelector === void 0 ? void 0 : _el$querySelector.form) || el.closest("form");
  return form;
};
const dom = {
  toNodeArray: toNodeArray,
  querySelectorAllAndMe: querySelectorAllAndMe,
  wrap: wrap,
  hide: hide,
  show: show,
  find_parents: find_parents,
  find_scoped: find_scoped,
  get_parents: get_parents,
  acquire_attribute: acquire_attribute,
  is_visible: is_visible,
  is_input: is_input,
  create_from_string: create_from_string,
  get_css_value: get_css_value,
  find_scroll_container: find_scroll_container,
  get_scroll_x: get_scroll_x,
  get_scroll_y: get_scroll_y,
  get_relative_position: get_relative_position,
  scroll_to_element: scroll_to_element,
  scroll_to_top: scroll_to_top,
  scroll_to_bottom: scroll_to_bottom,
  get_data: get_data,
  set_data: set_data,
  delete_data: delete_data,
  template: template,
  get_visible_ratio: get_visible_ratio,
  escape_css_id: escape_css_id,
  element_uuid: element_uuid,
  find_form: find_form,
  add_event_listener: _events__WEBPACK_IMPORTED_MODULE_0__["default"].add_event_listener,
  // BBB export. TODO: Remove in an upcoming version.
  remove_event_listener: _events__WEBPACK_IMPORTED_MODULE_0__["default"].remove_event_listener // BBB export. TODO: Remove in an upcoming version.
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (dom);

/***/ }),

/***/ "./node_modules/@patternslib/patternslib/src/core/events.js":
/*!******************************************************************!*\
  !*** ./node_modules/@patternslib/patternslib/src/core/events.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   event_listener_map: () => (/* binding */ event_listener_map)
/* harmony export */ });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "./node_modules/@patternslib/patternslib/src/core/utils.js");


// Event related methods and event factories

// Event listener registration for easy-to-remove event listeners.
// once Safari supports the ``signal`` option for addEventListener we can abort
// event handlers by calling AbortController.abort().
const event_listener_map = new Map();

/**
 * Add an event listener to a DOM element under a unique id.
 * If a event is registered under the same id for the same element, the old handler is removed first.
 *
 * @param {DOM Node} el - The element to register the event for.
 * @param {string} event_type - The event type to listen for.
 * @param {string} id - A unique id under which the event is registered.
 * @param {function} cb - The event handler / callback function.
 * @param {Object} opts - Options for the addEventListener API.
 *
 */
const add_event_listener = (el, event_type, id, cb, opts = {}) => {
  if (!(el !== null && el !== void 0 && el.addEventListener)) {
    return; // nothing to do.
  }
  remove_event_listener(el, id); // do not register one listener twice.

  // Create event_listener_map entry if not existent.
  if (!event_listener_map.has(el)) {
    event_listener_map.set(el, new Map());
  }
  let _cb = cb;
  if ((opts === null || opts === void 0 ? void 0 : opts.once) === true) {
    // For `once` events, also remove the entry from the event_listener_map.
    _cb = e => {
      var _event_listener_map$g;
      (_event_listener_map$g = event_listener_map.get(el)) === null || _event_listener_map$g === void 0 || _event_listener_map$g.delete(id);
      cb(e);
    };
  }
  // Only `capture` option is necessary for `removeEventListener`.
  event_listener_map.get(el).set(id, [event_type, _cb, opts.capture ? opts : undefined]);
  el.addEventListener(event_type, _cb, opts);
};

/**
 * Remove an event listener from a DOM element under a unique id.
 *
 * If an element and id are given, the event listeners for the given element matching the id are removed.
 * If an element but no id is given, all event listeners for that element are removed.
 * If an id but no element is given, all event listeners for any element matching the id are removed.
 * If no element and no id are given, all event listeners are removed.
 *
 * The id can be a wildcard string, e.g. `test-*-event`, which would match any
 * event which starts with "test-" and ends with "-event". The wildcard "*" can
 * be anywhere in the string and also be used multiple times. If no wildcard is
 * present the search string is used for an exact match.
 *
 * @param {DOM Node} [el] - The element to register the event for.
 * @param {string} [id] - A unique id under which the event is registered.
 *                        Can be a wildcard string.
 *
 */
const remove_event_listener = (el, id) => {
  const els = el ? [el] : event_listener_map.keys();
  for (const el of els) {
    if (!(el !== null && el !== void 0 && el.removeEventListener)) {
      return; // nothing to do.
    }
    const el_events = event_listener_map.get(el);
    if (!el_events) {
      return;
    }
    let entries;
    if (id) {
      // remove event listener with matching id
      entries = [...el_events.entries()].filter(entry => _utils__WEBPACK_IMPORTED_MODULE_0__["default"].regexp_from_wildcard(id).test(entry[0]));
    } else {
      // remove all event listeners of element
      entries = el_events.entries();
    }
    for (const entry of entries || []) {
      // Remove event listener
      el.removeEventListener(entry[1][0], entry[1][1], entry[1][2]);
      // Delete entry from event_listener_map
      event_listener_map.get(el).delete(entry[0]);
      // Delete element from event_listener_map if no more events are registered.
      if (!event_listener_map.get(el).size) {
        event_listener_map.delete(el);
      }
    }
  }
};

/**
 * Await an event to be thrown.
 *
 * Usage:
 *     await events.await_event(button, "click");
 *
 * @param {DOM Node} el - The element to listen on.
 * @param {String} event_name - The event name to listen for.
 *
 * @returns {Promise} - Returns a Promise which can be used for ``await`` and which will be resolved when the event is throwm.
 *
 */
const await_event = (el, event_name) => {
  // See: https://stackoverflow.com/a/44746691/1337474
  return new Promise(resolve => el.addEventListener(event_name, resolve, {
    once: true
  }));
};

/**
 * Await pattern init.
 *
 * Usage:
 *     await events.await_pattern_init(PATTERN);
 *
 * @param {Pattern instance} pattern - The pattern instance.
 *
 * @returns {Promise} - Returns a Promise which can be used for ``await`` and which will be resolved when the event is throwm.
 *
 */
const await_pattern_init = pattern => {
  // See: https://stackoverflow.com/a/44746691/1337474
  return new Promise((resolve, reject) => {
    // Case initialized
    pattern.one("init", e => {
      if (e.target !== pattern.el) {
        // Don't handle bubbling init events from child elements. We
        // want to check on init events coming directly from this
        // Pattern's element.
        return;
      }
      // Resolve promise and unregister the not-init event handler.
      remove_event_listener(pattern.el, `basepattern-one--not-init.${pattern.name}.patterns`);
      resolve();
    });

    // Case not initialized
    pattern.one("not-init", e => {
      if (e.target !== pattern.el) {
        // Don't handle bubbling not-init events from child elements.
        // We want to check on not-init events coming directly from
        // this Pattern's element.
        return;
      }
      // Reject promise and unregister the init event handler.
      remove_event_listener(pattern.el, `basepattern-one--init.${pattern.name}.patterns`);
      reject();
    });
  }).catch(() => {
    throw new Error(`Pattern "${pattern.name}" not initialized.`);
  });
};

/**
 * Event factories
 */

/** Generic event factory.
 *
 * A event factory for a bubbling and cancelable generic event.
 *
 * @param {string} name - The event name.
 * @returns {Event} - Returns a blur event.
 */
const generic_event = name => {
  return new Event(name, {
    bubbles: true,
    cancelable: true
  });
};
const blur_event = () => {
  return new Event("blur", {
    bubbles: false,
    cancelable: false
  });
};
const click_event = () => {
  return new Event("click", {
    bubbles: true,
    cancelable: true
  });
};
const change_event = () => {
  return new Event("change", {
    bubbles: true,
    cancelable: false
  });
};
const focus_event = () => {
  return new Event("focus", {
    bubbles: false,
    cancelable: false
  });
};
const input_event = () => {
  return new Event("input", {
    bubbles: true,
    cancelable: false
  });
};
const mousedown_event = () => {
  return new Event("mousedown", {
    bubbles: true,
    cancelable: true
  });
};
const mouseup_event = () => {
  return new Event("mouseup", {
    bubbles: true,
    cancelable: true
  });
};
const scroll_event = () => {
  return new Event("scroll", {
    bubbles: true,
    cancelable: false
  });
};
const submit_event = ({
  submitter
} = {
  submitter: undefined
}) => {
  const event = new Event("submit", {
    bubbles: true,
    cancelable: true
  });
  event.submitter = submitter; // undefined or the submitting element
  return event;
};
const dragstart_event = () => {
  return new Event("dragstart", {
    bubbles: true,
    cancelable: true
  });
};
const dragend_event = () => {
  return new Event("dragend", {
    bubbles: true,
    cancelable: true
  });
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  add_event_listener: add_event_listener,
  remove_event_listener: remove_event_listener,
  await_event: await_event,
  await_pattern_init: await_pattern_init,
  generic_event: generic_event,
  blur_event: blur_event,
  click_event: click_event,
  change_event: change_event,
  focus_event: focus_event,
  input_event: input_event,
  mousedown_event: mousedown_event,
  mouseup_event: mouseup_event,
  scroll_event: scroll_event,
  submit_event: submit_event,
  dragstart_event: dragstart_event,
  dragend_event: dragend_event
});

/***/ }),

/***/ "./node_modules/@patternslib/patternslib/src/core/logging.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@patternslib/patternslib/src/core/logging.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Patterns logging - minimal logging framework
 *
 * Copyright 2012 Simplon B.V.
 */

// source: https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Function/bind
if (!Function.prototype.bind) {
  Function.prototype.bind = function (oThis) {
    if (typeof this !== "function") {
      // closest thing possible to the ECMAScript 5 internal IsCallable function
      throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");
    }
    var aArgs = Array.prototype.slice.call(arguments, 1),
      fToBind = this,
      fNOP = function () {},
      fBound = function () {
        return fToBind.apply(this instanceof fNOP && oThis ? this : oThis, aArgs.concat(Array.prototype.slice.call(arguments)));
      };
    fNOP.prototype = this.prototype;
    fBound.prototype = new fNOP();
    return fBound;
  };
}
var root,
  // root logger instance
  writer; // writer instance, used to output log entries

var Level = {
  DEBUG: 10,
  INFO: 20,
  WARN: 30,
  ERROR: 40,
  FATAL: 50
};
function ConsoleWriter() {}
ConsoleWriter.prototype = {
  output: function (log_name, level, messages) {
    if (log_name) messages.unshift(log_name + ":");
    if (level <= Level.DEBUG) {
      // console.debug exists but is deprecated
      messages.unshift("[DEBUG]");
      console.log.apply(console, messages);
    } else if (level <= Level.INFO) console.info.apply(console, messages);else if (level <= Level.WARN) console.warn.apply(console, messages);else console.error.apply(console, messages);
  }
};
function Logger(name, parent) {
  this._loggers = {};
  this.name = name || "";
  this._parent = parent || null;
  if (!parent) {
    this._enabled = true;
    this._level = Level.WARN;
  }
}
Logger.prototype = {
  getLogger: function (name) {
    var path = name.split("."),
      root = this,
      route = this.name ? [this.name] : [];
    while (path.length) {
      var entry = path.shift();
      route.push(entry);
      if (!(entry in root._loggers)) root._loggers[entry] = new Logger(route.join("."), root);
      root = root._loggers[entry];
    }
    return root;
  },
  _getFlag: function (flag) {
    var context = this;
    flag = "_" + flag;
    while (context !== null) {
      if (context[flag] !== undefined) return context[flag];
      context = context._parent;
    }
    return null;
  },
  setEnabled: function (state) {
    this._enabled = !!state;
  },
  isEnabled: function () {
    this._getFlag("enabled");
  },
  setLevel: function (level) {
    if (typeof level === "number") this._level = level;else if (typeof level === "string") {
      level = level.toUpperCase();
      if (level in Level) this._level = Level[level];
    }
  },
  getLevel: function () {
    return this._getFlag("level");
  },
  log: function (level, messages) {
    if (!messages.length || !this._getFlag("enabled") || level < this._getFlag("level")) return;
    messages = Array.prototype.slice.call(messages);
    writer.output(this.name, level, messages);
  },
  debug: function () {
    this.log(Level.DEBUG, arguments);
  },
  info: function () {
    this.log(Level.INFO, arguments);
  },
  warn: function () {
    this.log(Level.WARN, arguments);
  },
  error: function () {
    this.log(Level.ERROR, arguments);
  },
  fatal: function () {
    this.log(Level.FATAL, arguments);
  }
};
function getWriter() {
  return writer;
}
function setWriter(w) {
  writer = w;
}
setWriter(new ConsoleWriter());
root = new Logger();
var logconfig = /loglevel(|-[^=]+)=([^&]+)/g,
  match;
while ((match = logconfig.exec(window.location.search)) !== null) {
  var logger = match[1] === "" ? root : root.getLogger(match[1].slice(1));
  logger.setLevel(match[2].toUpperCase());
}
var api = {
  Level: Level,
  getLogger: root.getLogger.bind(root),
  setEnabled: root.setEnabled.bind(root),
  isEnabled: root.isEnabled.bind(root),
  setLevel: root.setLevel.bind(root),
  getLevel: root.getLevel.bind(root),
  debug: root.debug.bind(root),
  info: root.info.bind(root),
  warn: root.warn.bind(root),
  error: root.error.bind(root),
  fatal: root.fatal.bind(root),
  getWriter: getWriter,
  setWriter: setWriter
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (api);

/***/ }),

/***/ "./node_modules/@patternslib/patternslib/src/core/parser.js":
/*!******************************************************************!*\
  !*** ./node_modules/@patternslib/patternslib/src/core/parser.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "webpack/sharing/consume/default/jquery/jquery");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ "./node_modules/@patternslib/patternslib/src/core/utils.js");
/* harmony import */ var _logging__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./logging */ "./node_modules/@patternslib/patternslib/src/core/logging.js");
// Patterns argument parser



class ArgumentParser {
  constructor(name) {
    this.order = [];
    this.parameters = {};
    this.attribute = "data-pat-" + name;
    this.enum_values = {};
    this.enum_conflicts = [];
    this.groups = {};
    this.possible_groups = {};
    this.log = _logging__WEBPACK_IMPORTED_MODULE_2__["default"].getLogger(name + ".parser");
    this.group_pattern = /([a-z][a-z0-9]*)-([A-Z][a-z0-0\-]*)/i;
    this.json_param_pattern = /^\s*\[?\s*{/i;
    this.named_param_pattern = /^\s*([a-z][a-z0-9\-]*)\s*:(.*)/is;
    this.token_pattern = /((["']).*?(?!\\)\2)|\s*(\S+)\s*/g;
  }
  _camelCase(str) {
    return str.replace(/\-([a-z])/g, (__, p1) => p1.toUpperCase());
  }
  addAlias(alias, original) {
    /* Add an alias for a previously added parser argument.
     *
     * Useful when you want to support both US and UK english argument
     * names.
     */
    if (this.parameters[original]) {
      this.parameters[original].alias = alias;
    } else {
      throw `Attempted to add an alias "${alias}" for a non-existing parser argument "${original}".`;
    }
  }
  addGroupToSpec(spec) {
    /* Determine wether an argument being parsed can be grouped and
     * update its specifications object accordingly.
     *
     * Internal method used by addArgument and addJSONArgument
     */
    const m = spec.name.match(this.group_pattern);
    if (m) {
      const group = m[1];
      const field = m[2];
      if (group in this.possible_groups) {
        const first_spec = this.possible_groups[group];
        const first_name = first_spec.name.match(this.group_pattern)[2];
        first_spec.group = group;
        first_spec.dest = first_name;
        this.groups[group] = new ArgumentParser();
        this.groups[group].addArgument(first_name, first_spec.value, first_spec.choices, first_spec.multiple);
        delete this.possible_groups[group];
      }
      if (group in this.groups) {
        this.groups[group].addArgument(field, spec.value, spec.choices, spec.multiple);
        spec.group = group;
        spec.dest = field;
      } else {
        this.possible_groups[group] = spec;
        spec.dest = this._camelCase(spec.name);
      }
    }
    return spec;
  }
  addJSONArgument(name, default_value) {
    /* Add an argument where the value is provided in JSON format.
     *
     * This is a different usecase than specifying all arguments to
     * the data-pat-... attributes in JSON format, and instead is part
     * of the normal notation except that a value is in JSON instead of
     * for example a string.
     */
    this.order.push(name);
    this.parameters[name] = this.addGroupToSpec({
      name: name,
      value: default_value,
      dest: name,
      group: null,
      type: "json"
    });
  }
  addArgument(name, default_value, choices, multiple) {
    const spec = {
      name: name,
      value: multiple && !Array.isArray(default_value) ? [default_value] : default_value,
      multiple: multiple,
      dest: name,
      group: null
    };
    if (choices && Array.isArray(choices) && choices.length) {
      spec.choices = choices;
      spec.type = this._typeof(choices[0]);
      for (const choice of choices) {
        if (this.enum_conflicts.indexOf(choice) !== -1) {
          continue;
        } else if (choice in this.enum_values) {
          this.enum_conflicts.push(choice);
          delete this.enum_values[choice];
        } else {
          this.enum_values[choice] = name;
        }
      }
    } else if (typeof spec.value === "string" && spec.value.slice(0, 1) === "$") {
      spec.type = this.parameters[spec.value.slice(1)].type;
    } else {
      // Note that this will get reset by _defaults if default_value is a function.
      spec.type = this._typeof(multiple ? spec.value[0] : spec.value);
    }
    this.order.push(name);
    this.parameters[name] = this.addGroupToSpec(spec);
  }
  _typeof(obj) {
    if (obj === null) {
      return "null";
    }
    return typeof obj;
  }
  _coerce(name, value) {
    const spec = this.parameters[name];
    if (typeof value !== spec.type) try {
      switch (spec.type) {
        case "json":
          value = JSON.parse(value);
          break;
        case "boolean":
          if (typeof value === "string") {
            value = value.toLowerCase();
            const num = parseInt(value, 10);
            if (!isNaN(num)) value = !!num;else value = value === "true" || value === "y" || value === "yes" || value === "y" || value === "on";
          } else if (typeof value === "number") {
            value = !!value;
          } else {
            throw `Cannot convert value for ${name} to boolean.`;
          }
          break;
        case "number":
          if (typeof value === "string") {
            value = parseInt(value, 10);
            if (isNaN(value)) {
              throw `Cannot convert value for ${name} to number.`;
            }
          } else if (typeof value === "boolean") {
            value = value + 0;
          } else {
            throw `Cannot convert value for ${name} to number.`;
          }
          break;
        case "string":
          value = value.toString();
          break;
        case "null": // Missing default values
        case "undefined":
          break;
        default:
          throw `Do not know how to convert value for ${name} of type ${typeof value} to ${spec.type}.`;
      }
    } catch (e) {
      this.log.warn(e);
      return null;
    }
    if (spec.choices && spec.choices.indexOf(value) === -1) {
      this.log.warn(`Illegal value for ${name}: ${value}.`);
      return null;
    }
    return value;
  }
  _set(opts, name, value) {
    if (!(name in this.parameters)) {
      this.log.debug(`Ignoring value for unknown argument: ${name}.`);
      return;
    }
    const spec = this.parameters[name];
    let parts;
    if (spec.multiple) {
      if (typeof value === "string") {
        parts = value.split(/,+/);
      } else {
        parts = value;
      }
      value = [];
      for (const part of parts) {
        const v = this._coerce(name, part.trim());
        if (v !== null) {
          value.push(v);
        }
      }
    } else {
      value = this._coerce(name, value);
      if (value === null) {
        return;
      }
    }
    opts[name] = value;
  }
  _split(text) {
    const tokens = [];
    text.replace(this.token_pattern, (match, quoted, __, simple) => {
      if (quoted) {
        tokens.push(quoted);
      } else if (simple) {
        tokens.push(simple);
      }
    });
    return tokens;
  }
  _parseExtendedNotation(argstring) {
    const opts = {};
    const parts = argstring.replace(/;;/g, "\0x1f").replace(/&amp;/g, "&amp\0x1f").split(/;/).map(el => el.replace(new RegExp("\0x1f", "g"), ";"));
    for (const part of parts) {
      if (!part) {
        continue;
      }
      const matches = part.match(this.named_param_pattern);
      if (!matches) {
        this.log.warn(`Invalid parameter: ${part}: ${argstring}.`);
        continue;
      }
      const name = matches[1];
      const value = matches[2].trim();
      const arg = Object.values(this.parameters).filter(it => it.alias === name);
      const is_alias = arg.length === 1;
      if (is_alias) {
        this._set(opts, arg[0].name, value);
      } else if (name in this.parameters) {
        this._set(opts, name, value);
      } else if (name in this.groups) {
        const subopt = this.groups[name]._parseShorthandNotation(value);
        for (const field in subopt) {
          this._set(opts, name + "-" + field, subopt[field]);
        }
      } else {
        this.log.warn(`Unknown named parameter: ${matches[1]}.`);
        continue;
      }
    }
    return opts;
  }
  _parseShorthandNotation(parameter) {
    const parts = this._split(parameter);
    const opts = {};
    let i = 0;
    while (parts.length) {
      const part = parts.shift().trim();
      let sense;
      let flag;
      let positional = true;
      if (part.slice(0, 3) === "no-") {
        sense = false;
        flag = part.slice(3);
      } else {
        sense = true;
        flag = part;
      }
      if (flag in this.parameters && this.parameters[flag].type === "boolean") {
        positional = false;
        this._set(opts, flag, sense);
      } else if (flag in this.enum_values) {
        positional = false;
        this._set(opts, this.enum_values[flag], flag);
      } else if (positional) this._set(opts, this.order[i], part);else {
        parts.unshift(part);
        break;
      }
      i++;
      if (i >= this.order.length) {
        break;
      }
    }
    if (parts.length) this.log.warn(`Ignore extra arguments: ${parts.join(" ")}.`);
    return opts;
  }
  _parse(parameter) {
    if (!parameter) {
      return {};
    }
    if (parameter.match(this.json_param_pattern)) {
      try {
        return JSON.parse(parameter);
      } catch (e) {
        this.log.warn(`Invalid JSON argument found: ${parameter}.`);
      }
    }
    if (parameter.match(this.named_param_pattern)) {
      return this._parseExtendedNotation(parameter);
    }
    const sep = parameter.indexOf(";");
    if (sep === -1) {
      return this._parseShorthandNotation(parameter);
    }
    const opts = this._parseShorthandNotation(parameter.slice(0, sep));
    const extended = this._parseExtendedNotation(parameter.slice(sep + 1));
    for (const name in extended) {
      opts[name] = extended[name];
    }
    return opts;
  }
  _defaults($el) {
    const result = {};
    for (const name in this.parameters) {
      if (typeof this.parameters[name].value === "function") {
        try {
          result[name] = this.parameters[name].value($el, name);
          this.parameters[name].type = typeof result[name];
        } catch (e) {
          this.log.error(`Default function for ${name} failed.`);
        }
      } else {
        result[name] = this.parameters[name].value;
      }
    }
    return result;
  }
  _cleanupOptions(options, group_options = true) {
    // Resolve references
    for (const name of Object.keys(options)) {
      const spec = this.parameters[name];
      if (spec === undefined) {
        continue;
      }
      if (options[name] === spec.value && typeof spec.value === "string" && spec.value.slice(0, 1) === "$") {
        options[name] = options[spec.value.slice(1)];
      }
    }
    if (group_options) {
      // Move options into groups and do renames
      for (const name of Object.keys(options)) {
        const spec = this.parameters[name];
        let target;
        if (spec === undefined) {
          continue;
        }
        if (spec.group) {
          if (typeof options[spec.group] !== "object") {
            options[spec.group] = {};
          }
          target = options[spec.group];
        } else {
          target = options;
        }
        if (spec.dest !== name) {
          target[spec.dest] = options[name];
          delete options[name];
        }
      }
    }
    return options;
  }
  parse($el, options, multiple, inherit = true, group_options = true) {
    if (!$el.jquery) {
      $el = jquery__WEBPACK_IMPORTED_MODULE_0___default()($el);
    }
    if (typeof options === "boolean" && multiple === undefined) {
      // Fix argument order: ``multiple`` passed instead of ``options``.
      multiple = options;
      options = {};
    }
    const stack = inherit ? [[this._defaults($el)]] : [[{}]];
    let $possible_config_providers;
    let final_length = 1;
    /*
     * XXX this is a workaround for:
     * - https://github.com/Patternslib/Patterns/issues/393
     *
     * Prevents the parser to pollute the pat-modal configuration
     * with data-pat-inject elements define in a `.pat-modal` parent element.
     *
     *  Probably this function should be completely revisited, see:
     * - https://github.com/Patternslib/Patterns/issues/627
     *
     */
    if (!inherit || $el.hasClass("pat-modal") && this.attribute === "data-pat-inject") {
      $possible_config_providers = $el;
    } else {
      $possible_config_providers = $el.parents(`[${this.attribute}]`).addBack();
    }
    for (const provider of $possible_config_providers) {
      let frame;
      const data = (jquery__WEBPACK_IMPORTED_MODULE_0___default()(provider).attr(this.attribute) || "").trim();
      if (!data) {
        continue;
      }
      const _parse = this._parse.bind(this);
      if (data.match(/&&/)) {
        frame = data.split(/\s*&&\s*/).map(_parse);
      } else {
        frame = _parse(data);
      }
      if (!Array.isArray(frame)) {
        frame = [frame];
      }
      final_length = Math.max(frame.length, final_length);
      stack.push(frame);
    }
    if (typeof options === "object") {
      if (Array.isArray(options)) {
        stack.push(options);
        final_length = Math.max(options.length, final_length);
      } else {
        stack.push([options]);
      }
    }
    if (!multiple) {
      final_length = 1;
    }
    const results = _utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].removeDuplicateObjects(_utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].mergeStack(stack, final_length)).map(current_value => this._cleanupOptions(current_value, group_options));
    return multiple ? results : results[0];
  }
}

// BBB
ArgumentParser.prototype.add_argument = ArgumentParser.prototype.addArgument;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ArgumentParser);

/***/ }),

/***/ "./node_modules/@patternslib/patternslib/src/core/registry.js":
/*!********************************************************************!*\
  !*** ./node_modules/@patternslib/patternslib/src/core/registry.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PATTERN_REGISTRY: () => (/* binding */ PATTERN_REGISTRY),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "webpack/sharing/consume/default/jquery/jquery");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dom */ "./node_modules/@patternslib/patternslib/src/core/dom.js");
/* harmony import */ var _logging__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./logging */ "./node_modules/@patternslib/patternslib/src/core/logging.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils */ "./node_modules/@patternslib/patternslib/src/core/utils.js");
/**
 * Patterns registry - Central registry and scan logic for patterns
 *
 * Copyright 2012-2013 Simplon B.V.
 * Copyright 2012-2013 Florian Friesdorf
 * Copyright 2013 Marko Durkovic
 * Copyright 2013 Rok Garbas
 * Copyright 2014-2015 Syslab.com GmBH, JC Brand
 */

/*
 * changes to previous patterns.register/scan mechanism
 * - if you want initialised class, do it in init
 * - init returns set of elements actually initialised
 * - handle once within init
 * - no turnstile anymore
 * - set pattern.jquery_plugin if you want it
 */




const log = _logging__WEBPACK_IMPORTED_MODULE_2__["default"].getLogger("registry");
const disable_re = /patterns-disable=([^&]+)/g;
const dont_catch_re = /patterns-dont-catch/g;
const disabled = {};
let dont_catch = false;
let match;
while ((match = disable_re.exec(window.location.search)) !== null) {
  disabled[match[1]] = true;
  log.info("Pattern disabled via url config:", match[1]);
}
while ((match = dont_catch_re.exec(window.location.search)) !== null) {
  dont_catch = true;
  log.info("I will not catch init exceptions");
}

/**
 * Global pattern registry.
 *
 * This is a singleton and shared among any instance of the Patternslib
 * registry since Patternslib version 8.
 *
 * You normally don't need this as the registry handles it for you.
 */
if (typeof window.__patternslib_registry === "undefined") {
  window.__patternslib_registry = {};
}
const PATTERN_REGISTRY = window.__patternslib_registry;
if (typeof window.__patternslib_registry_initialized === "undefined") {
  window.__patternslib_registry_initialized = false;
}
const registry = {
  patterns: PATTERN_REGISTRY,
  // reference to global patterns registry
  // as long as the registry is not initialized, pattern
  // registration just registers a pattern. Once init is called,
  // the DOM is scanned. After that registering a new pattern
  // results in rescanning the DOM only for this pattern.
  init() {
    jquery__WEBPACK_IMPORTED_MODULE_0___default()(document).ready(function () {
      if (window.__patternslib_registry_initialized) {
        // Do not reinitialize a already initialized registry.
        return;
      }
      window.__patternslib_registry_initialized = true;
      log.debug("Loaded: " + Object.keys(registry.patterns).sort().join(", "));
      registry.scan(document.body);
      log.debug("Finished initial scan.");
    });
  },
  clear() {
    // Removes all patterns from the registry. Currently only being
    // used in tests.
    for (const name in registry.patterns) {
      delete registry.patterns[name];
    }
  },
  transformPattern(name, content) {
    var _pattern$prototype;
    /* Call the transform method on the pattern with the given name, if
     * it exists.
     */
    if (disabled[name]) {
      log.debug(`Skipping disabled pattern: ${name}.`);
      return;
    }
    const pattern = registry.patterns[name];
    const transform = pattern.transform || ((_pattern$prototype = pattern.prototype) === null || _pattern$prototype === void 0 ? void 0 : _pattern$prototype.transform);
    if (transform) {
      try {
        transform(jquery__WEBPACK_IMPORTED_MODULE_0___default()(content));
      } catch (e) {
        if (dont_catch) {
          throw e;
        }
        log.error(`Transform error for pattern ${name}.`, e);
      }
    }
  },
  initPattern(name, el, trigger) {
    /* Initialize the pattern with the provided name and in the context
     * of the passed in DOM element.
     */
    const $el = jquery__WEBPACK_IMPORTED_MODULE_0___default()(el);
    const pattern = registry.patterns[name];
    const plog = _logging__WEBPACK_IMPORTED_MODULE_2__["default"].getLogger(`pat.${name}`);
    if (el.matches(pattern.trigger)) {
      plog.debug("Initialising.", el);
      try {
        if (pattern.init) {
          // old style initialisation
          pattern.init($el, null, trigger);
        } else {
          // class based pattern initialisation
          new pattern($el, null, trigger);
        }
        plog.debug("done.");
      } catch (e) {
        if (dont_catch) {
          throw e;
        }
        plog.error("Caught error:", e);
      }
    }
  },
  orderPatterns(patterns) {
    // Always add pat-validation as first pattern, so that it can prevent
    // other patterns from reacting to submit events if form validation
    // fails.
    if (patterns.includes("validation")) {
      patterns.splice(patterns.indexOf("validation"), 1);
      patterns.unshift("validation");
    }
    // Add clone-code to the very beginning - we want to copy the markup
    // before any other patterns changed the markup.
    if (patterns.includes("clone-code")) {
      patterns.splice(patterns.indexOf("clone-code"), 1);
      patterns.unshift("clone-code");
    }
    return patterns;
  },
  scan(content, patterns, trigger) {
    if (!content) {
      return;
    }
    if (typeof content === "string") {
      content = document.querySelector(content);
    } else if (content instanceof Text) {
      // No need to scan a TextNode.
      return;
    } else if (content.jquery) {
      content = content[0];
    }
    const selectors = [];
    patterns = this.orderPatterns(patterns || Object.keys(registry.patterns));
    for (const name of patterns) {
      this.transformPattern(name, content);
      const pattern = registry.patterns[name];
      if (pattern.trigger) {
        selectors.unshift(pattern.trigger);
      }
    }
    let matches = _dom__WEBPACK_IMPORTED_MODULE_1__["default"].querySelectorAllAndMe(content, selectors.map(it => it.trim().replace(/,$/, "")).join(","));
    matches = matches.filter(el => {
      var _el$parentNode, _el$parentNode$closes, _el$parentNode2, _el$parentNode2$close, _el$parentNode3, _el$parentNode3$close, _el$parentNode4, _el$parentNode4$close;
      // Filter out patterns:
      // - with class ``.disable-patterns``
      // - wrapped in ``.disable-patterns`` elements
      // - wrapped in ``<pre>`` elements
      // - wrapped in ``<template>`` elements
      return !el.matches(".disable-patterns") && !(el !== null && el !== void 0 && (_el$parentNode = el.parentNode) !== null && _el$parentNode !== void 0 && (_el$parentNode$closes = _el$parentNode.closest) !== null && _el$parentNode$closes !== void 0 && _el$parentNode$closes.call(_el$parentNode, ".disable-patterns")) && !(el !== null && el !== void 0 && (_el$parentNode2 = el.parentNode) !== null && _el$parentNode2 !== void 0 && (_el$parentNode2$close = _el$parentNode2.closest) !== null && _el$parentNode2$close !== void 0 && _el$parentNode2$close.call(_el$parentNode2, "pre")) && !(el !== null && el !== void 0 && (_el$parentNode3 = el.parentNode) !== null && _el$parentNode3 !== void 0 && (_el$parentNode3$close = _el$parentNode3.closest) !== null && _el$parentNode3$close !== void 0 && _el$parentNode3$close.call(_el$parentNode3, "template")) &&
      // NOTE: not strictly necessary. Template is a DocumentFragment and not reachable except for IE.
      !el.matches(".cant-touch-this") &&
      // BBB. TODO: Remove with next major version.
      !(el !== null && el !== void 0 && (_el$parentNode4 = el.parentNode) !== null && _el$parentNode4 !== void 0 && (_el$parentNode4$close = _el$parentNode4.closest) !== null && _el$parentNode4$close !== void 0 && _el$parentNode4$close.call(_el$parentNode4, ".cant-touch-this")) // BBB. TODO: Remove with next major version.
      ;
    });

    // walk list backwards and initialize patterns inside-out.
    for (const el of matches.reverse()) {
      for (const name of patterns) {
        this.initPattern(name, el, trigger);
      }
    }
    document.body.classList.add("patterns-loaded");
  },
  register(pattern, name) {
    name = name || pattern.name;
    if (!name) {
      log.error("Pattern lacks a name.", pattern);
      return false;
    }
    if (registry.patterns[name]) {
      log.debug(`Already have a pattern called ${name}.`);
      return false;
    }
    // register pattern to be used for scanning new content
    registry.patterns[name] = pattern;

    // register pattern as jquery plugin
    if (pattern.jquery_plugin) {
      const plugin_name = ("pat-" + name).replace(/-([a-zA-Z])/g, function (match, p1) {
        return p1.toUpperCase();
      });
      (jquery__WEBPACK_IMPORTED_MODULE_0___default().fn)[plugin_name] = _utils__WEBPACK_IMPORTED_MODULE_3__["default"].jqueryPlugin(pattern);
      // BBB 2012-12-10 and also for Mockup patterns.
      (jquery__WEBPACK_IMPORTED_MODULE_0___default().fn)[plugin_name.replace(/^pat/, "pattern")] = (jquery__WEBPACK_IMPORTED_MODULE_0___default().fn)[plugin_name];
    }
    log.debug(`Registered pattern ${name}`, pattern);
    if (window.__patternslib_registry_initialized) {
      // Once the first initialization has been done, do only scan for
      // newly registered patterns.
      registry.scan(document.body, [name]);
      log.debug(`Re-scanned dom with newly registered pattern ${name}.`);
    }
    return true;
  }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (registry);

/***/ }),

/***/ "./node_modules/@patternslib/patternslib/src/core/utils.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@patternslib/patternslib/src/core/utils.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "webpack/sharing/consume/default/jquery/jquery");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dom */ "./node_modules/@patternslib/patternslib/src/core/dom.js");


const _MS_PER_DAY = 1000 * 60 * 60 * 24; // Milliseconds per day.

(jquery__WEBPACK_IMPORTED_MODULE_0___default().fn).safeClone = function () {
  var $clone = this.clone();
  return $clone;
};

// Production steps of ECMA-262, Edition 5, 15.4.4.18
// Reference: http://es5.github.io/#x15.4.4.18
if (!Array.prototype.forEach) {
  Array.prototype.forEach = function (callback, thisArg) {
    var T, k;
    if (this === null) {
      throw new TypeError(" this is null or not defined");
    }
    // 1. Let O be the result of calling ToObject passing the |this| value as the argument.
    var O = Object(this);
    // 2. Let lenValue be the result of calling the Get internal method of O with the argument "length".
    // 3. Let len be ToUint32(lenValue).
    var len = O.length >>> 0;
    // 4. If IsCallable(callback) is false, throw a TypeError exception.
    // See: http://es5.github.com/#x9.11
    if (typeof callback !== "function") {
      throw new TypeError(callback + " is not a function");
    }
    // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.
    if (arguments.length > 1) {
      T = thisArg;
    }
    // 6. Let k be 0
    k = 0;
    // 7. Repeat, while k < len
    while (k < len) {
      var kValue;
      // a. Let Pk be ToString(k).
      //   This is implicit for LHS operands of the in operator
      // b. Let kPresent be the result of calling the HasProperty internal method of O with argument Pk.
      //   This step can be combined with c
      // c. If kPresent is true, then
      if (k in O) {
        // i. Let kValue be the result of calling the Get internal method of O with argument Pk.
        kValue = O[k];
        // ii. Call the Call internal method of callback with T as the this value and
        // argument list containing kValue, k, and O.
        callback.call(T, kValue, k, O);
      }
      // d. Increase k by 1.
      k++;
    }
    // 8. return undefined
  };
}
var singleBoundJQueryPlugin = function (pattern, method, options) {
  /* This is a jQuery plugin for patterns which are invoked ONCE FOR EACH
   * matched element in the DOM.
   *
   * This is how the Mockup-type patterns behave. They are constructor
   * functions which need to be invoked once per jQuery-wrapped DOM node
   * for all DOM nodes on which the pattern applies.
   */
  var $this = this;
  $this.each(function () {
    var pat,
      $el = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this);
    pat = pattern.init($el, options);
    if (method) {
      if (pat[method] === undefined) {
        jquery__WEBPACK_IMPORTED_MODULE_0___default().error("Method " + method + " does not exist on jQuery." + pattern.name);
        return false;
      }
      if (method.charAt(0) === "_") {
        jquery__WEBPACK_IMPORTED_MODULE_0___default().error("Method " + method + " is private on jQuery." + pattern.name);
        return false;
      }
      pat[method].apply(pat, [options]);
    }
  });
  return $this;
};
var pluralBoundJQueryPlugin = function (pattern, method, options) {
  /* This is a jQuery plugin for patterns which are invoked ONCE FOR ALL
   * matched elements in the DOM.
   *
   * This is how the vanilla Patternslib-type patterns behave. They are
   * simple objects with an init method and this method gets called once
   * with a list of jQuery-wrapped DOM nodes on which the pattern
   * applies.
   */
  var $this = this;
  if (method) {
    if (pattern[method]) {
      return pattern[method].apply($this, [$this].concat([options]));
    } else {
      jquery__WEBPACK_IMPORTED_MODULE_0___default().error("Method " + method + " does not exist on jQuery." + pattern.name);
    }
  } else {
    pattern.init.apply($this, [$this].concat([options]));
  }
  return $this;
};
var jqueryPlugin = function (pattern) {
  return function (method, options) {
    var $this = this;
    if ($this.length === 0) {
      return $this;
    }
    if (typeof method === "object") {
      options = method;
      method = undefined;
    }
    if (typeof pattern === "function") {
      return singleBoundJQueryPlugin.call(this, pattern, method, options);
    } else {
      return pluralBoundJQueryPlugin.call(this, pattern, method, options);
    }
  };
};

// Is a given variable an object?
function isObject(obj) {
  var type = typeof obj;
  return type === "function" || type === "object" && !!obj;
}

// Extend a given object with all the properties in passed-in object(s).
function extend(obj) {
  if (!isObject(obj)) return obj;
  var source, prop;
  for (var i = 1, length = arguments.length; i < length; i++) {
    source = arguments[i];
    for (prop in source) {
      if (hasOwnProperty.call(source, prop)) {
        obj[prop] = source[prop];
      }
    }
  }
  return obj;
}
// END: Taken from Underscore.js until here.

function findLabel(input) {
  var $label;
  for (var label = input.parentNode; label && label.nodeType !== 11; label = label.parentNode) {
    if (label.tagName === "LABEL") {
      return label;
    }
  }
  if (input.id) {
    $label = jquery__WEBPACK_IMPORTED_MODULE_0___default()('label[for="' + input.id + '"]');
  }
  if ($label && $label.length === 0 && input.form) {
    $label = jquery__WEBPACK_IMPORTED_MODULE_0___default()('label[for="' + input.name + '"]', input.form);
  }
  if ($label && $label.length) {
    return $label[0];
  } else {
    return null;
  }
}

// Taken from http://stackoverflow.com/questions/3446170/escape-string-for-use-in-javascript-regex
function escapeRegExp(str) {
  return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
}

/**
 * Create a RegExp object of a wildcard search string.
 *
 * @param {string} wildcard: A search string which can contain wildcards "*".
 *                           The wildcard "*" can be anywhere in the string and
 *                           can also be used multiple times. If no wildcard is
 *                           present the search string is used for an exact match.

 * @returns {RegExp}: A RegExp object which can be used to match strings.
 */
function regexp_from_wildcard(wildcard) {
  let regexp = wildcard.replace(/[\-\[\]{}()+?.,\\\^$|#\s]/g, "\\$&");
  regexp = regexp.replace(/[*]/g, ".*");
  regexp = new RegExp(`^${regexp}$`);
  return regexp;
}

/**
 * Remove classes from a list of targets if they match a specific pattern.
 *
 * @param {Node, NodeList} targets: Dom Node or NodeList where the classes should be removed.
 * @param {string} classes: String matching classes to be removed.
 *                          You can add a "*" as wildcard to search for classes to be removed.
 *                          E.g. "icon-*-alert" to remove any of "icon-1-alert icon-2-alert".
 *
 * @returns {undefined}: This method directly operates on the targets.
 */
function removeWildcardClass(targets, classes) {
  targets = utils.ensureArray(targets);
  if (classes.indexOf("*") === -1) {
    for (const target of targets) {
      target.classList.remove(classes);
    }
  } else {
    const matcher = regexp_from_wildcard(classes);
    for (const target of targets) {
      const class_list = (target.getAttribute("class") || "").split(/\s+/);
      if (!class_list.length) {
        continue;
      }
      const ok = class_list.filter(it => !matcher.test(it));
      if (ok.length) {
        target.setAttribute("class", ok.join(" "));
      } else {
        target.removeAttribute("class");
      }
    }
  }
}
function hasValue(el) {
  if (el.tagName === "INPUT") {
    if (el.type === "checkbox" || el.type === "radio") {
      return el.checked;
    }
    return el.value !== "";
  }
  if (el.tagName === "SELECT") {
    return el.selectedIndex !== -1;
  }
  if (el.tagName === "TEXTAREA") {
    return el.value !== "";
  }
  return false;
}
const hideOrShow = (nodes, visible, options, pattern_name) => {
  nodes = _dom__WEBPACK_IMPORTED_MODULE_1__["default"].toNodeArray(nodes);
  const transitions = {
    none: {
      hide: "hide",
      show: "show"
    },
    fade: {
      hide: "fadeOut",
      show: "fadeIn"
    },
    slide: {
      hide: "slideUp",
      show: "slideDown"
    }
  };
  const duration = options.transition === "css" || options.transition === "none" ? null : options.effect.duration;
  const on_complete = el => {
    el.classList.remove("in-progress");
    el.classList.add(visible ? "visible" : "hidden");
    jquery__WEBPACK_IMPORTED_MODULE_0___default()(el).trigger("pat-update", {
      pattern: pattern_name,
      action: "attribute-changed",
      dom: el,
      transition: "complete"
    });
  };
  for (const el of nodes) {
    el.classList.remove("visible");
    el.classList.remove("hidden");
    el.classList.remove("in-progress");
    if (duration) {
      const t = transitions[options.transition];
      el.classList.add("in-progress");
      jquery__WEBPACK_IMPORTED_MODULE_0___default()(el).trigger("pat-update", {
        pattern: pattern_name,
        action: "attribute-changed",
        dom: el,
        transition: "start"
      });
      jquery__WEBPACK_IMPORTED_MODULE_0___default()(el)[visible ? t.show : t.hide]({
        duration: duration,
        easing: options.effect.easing,
        complete: () => on_complete(el)
      });
    } else {
      if (options.transition !== "css") {
        _dom__WEBPACK_IMPORTED_MODULE_1__["default"][visible ? "show" : "hide"](el);
      }
      on_complete(el);
    }
  }
};
function addURLQueryParameter(fullURL, param, value) {
  /* Using a positive lookahead (?=\=) to find the given parameter,
   * preceded by a ? or &, and followed by a = with a value after
   * than (using a non-greedy selector) and then followed by
   * a & or the end of the string.
   *
   * Taken from http://stackoverflow.com/questions/7640270/adding-modify-query-string-get-variables-in-a-url-with-javascript
   */
  var val = new RegExp("(\\?|\\&)" + param + "=.*?(?=(&|$))"),
    parts = fullURL.toString().split("#"),
    url = parts[0],
    hash = parts[1],
    qstring = /\?.+$/,
    newURL = url;
  // Check if the parameter exists
  if (val.test(url)) {
    // if it does, replace it, using the captured group
    // to determine & or ? at the beginning
    newURL = url.replace(val, "$1" + param + "=" + value);
  } else if (qstring.test(url)) {
    // otherwise, if there is a query string at all
    // add the param to the end of it
    newURL = url + "&" + param + "=" + value;
  } else {
    // if there's no query string, add one
    newURL = url + "?" + param + "=" + value;
  }
  if (hash) {
    newURL += "#" + hash;
  }
  return newURL;
}
function removeDuplicateObjects(objs) {
  /* Given an array of objects, remove any duplicate objects which might
   * be present.
   */
  const comparator = function (k, v) {
    return this[k] === v;
  };
  return objs.reduce(function (list, next_obj) {
    let is_duplicate = false;
    for (const obj of list) {
      is_duplicate = Object.keys(obj).length === Object.keys(next_obj).length && Object.entries(obj).filter(it => !comparator.bind(next_obj)(it[0], it[1])).length === 0;
    }
    if (!is_duplicate) {
      list.push(next_obj);
    }
    return list;
  }, []);
}
function mergeStack(stack, length) {
  /* Given a list of lists of objects (which for brevity we call a stack),
   * return a list of objects where each object is the merge of all the
   * corresponding original objects at that particular index.
   *
   * If a certain sub-list doesn't have an object at that particular
   * index, the last object in that list is merged.
   */
  const results = [];
  for (let i = 0; i < length; i++) {
    results.push({});
  }
  for (const frame of stack) {
    const frame_length = frame.length - 1;
    for (let x = 0; x < length; x++) {
      results[x] = jquery__WEBPACK_IMPORTED_MODULE_0___default().extend(results[x] || {}, frame[x > frame_length ? frame_length : x]);
    }
  }
  return results;
}
function isElementInViewport(el, partial = false, offset = 0) {
  /* returns true if element is visible to the user ie. is in the viewport.
   * Setting partial parameter to true, will only check if a part of the element is visible
   * in the viewport, specifically that some part of that element is touching the top part
   * of the viewport. This only applies to the vertical direction, ie. doesnt check partial
   * visibility for horizontal scrolling
   * some code taken from:
   * http://stackoverflow.com/questions/123999/how-to-tell-if-a-dom-element-is-visible-in-the-current-viewport/7557433#7557433
   */
  if (el instanceof (jquery__WEBPACK_IMPORTED_MODULE_0___default())) {
    el = el[0];
  }
  const rec = el.getBoundingClientRect();
  const rec_values = [rec.top, rec.bottom, rec.left, rec.right];
  if (rec_values.every(val => val === 0)) {
    // if every property of rec is 0, the element is invisible;
    return false;
  } else if (partial) {
    // when using getBoundingClientRect() (in the vertical case)
    // negative means above top of viewport, positive means below top of viewport
    // therefore for part of the element to be touching or crossing the top of the viewport
    // rec.top must <= 0 and rec.bottom must >= 0
    // an optional tolerance offset can be added for when the desired element is not exactly
    // toucing the top of the viewport but needs to be considered as touching.
    return rec.top <= 0 + offset && rec.bottom >= 0 + offset
    //(rec.top >= 0+offset && rec.top <= window.innerHeight) // this checks if the element
    // touches bottom part of viewport
    // XXX do we want to include a check for the padding of an element?
    // using window.getComputedStyle(target).paddingTop
    ;
  } else {
    // this will return true if the entire element is completely in the viewport
    return rec.top >= 0 && rec.left >= 0 && rec.bottom <= (window.innerHeight || document.documentElement.clientHeight) && rec.right <= (window.innerWidth || document.documentElement.clientWidth);
  }
}

/* parseTime - Parse a duration from a string and return the parsed time in milliseconds.
 *
 * @param {String} time - A duration/time string like ``1ms``, ``1s`` or ``1m``.
 *
 * @returns {Number} - A integer which represents the parsed time in milliseconds.
 */
function parseTime(time) {
  var m = /^(\d+(?:\.\d+)?)\s*(\w*)/.exec(time);
  if (!m) {
    throw new Error("Invalid time");
  }
  var amount = parseFloat(m[1]);
  switch (m[2]) {
    case "s":
      return Math.round(amount * 1000);
    case "m":
      return Math.round(amount * 1000 * 60);
    case "ms":
    default:
      return Math.round(amount);
  }
}

/*

 * parseLength - Parse a length from a string and return the parsed length in
 * pixels.

 * @param {String} length - A length string like `1px` or `25%`. Lengths without a unit are treated as pixels.
 * @param {Number} reference_length - The reference length to use for percentage lengths.
 *
 * @returns {Number} - A integer which represents the parsed length in pixels.
 *
 * @throws {Error} - If the length string is invalid.
 *
 * @example
 * parseLength("1px"); // 1
 * parseLength("10%", 100); // 10
 *
 */
function parseLength(length, reference_length = null) {
  const m = /^(\d+(?:\.\d+)?)\s*(\%?\w*)/.exec(length);
  if (!m) {
    throw new Error("Invalid length");
  }
  const amount = parseFloat(m[1]);
  switch (m[2]) {
    case "px":
      return Math.round(amount);
    case "%":
      if (!reference_length) {
        return 0;
      }
      return reference_length / 100 * Math.round(amount);
    case "vw":
      return Math.round(amount * window.innerWidth / 100);
    case "vh":
      return Math.round(amount * window.innerHeight / 100);
    case "vmin":
      return Math.round(amount * Math.min(window.innerWidth, window.innerHeight) / 100);
    case "vmax":
      return Math.round(amount * Math.max(window.innerWidth, window.innerHeight) / 100);
    default:
      return Math.round(amount);
  }
}

// Return a jQuery object with elements related to an input element.
function findRelatives(el) {
  var $el = jquery__WEBPACK_IMPORTED_MODULE_0___default()(el),
    $relatives = jquery__WEBPACK_IMPORTED_MODULE_0___default()(el),
    $label = jquery__WEBPACK_IMPORTED_MODULE_0___default()();
  $relatives = $relatives.add($el.closest("label"));
  $relatives = $relatives.add($el.closest("fieldset"));
  if (el.id) $label = jquery__WEBPACK_IMPORTED_MODULE_0___default()("label[for='" + el.id + "']");
  if (!$label.length) {
    var $form = $el.closest("form");
    if (!$form.length) $form = jquery__WEBPACK_IMPORTED_MODULE_0___default()(document.body);
    $label = $form.find("label[for='" + el.name + "']");
  }
  $relatives = $relatives.add($label);
  return $relatives;
}
function get_bounds(el) {
  // Return bounds of an element with it's values rounded and converted to ints.
  const bounds = el.getBoundingClientRect();
  return {
    x: parseInt(Math.round(bounds.x), 10) || 0,
    y: parseInt(Math.round(bounds.y), 10) || 0,
    top: parseInt(Math.round(bounds.top), 10) || 0,
    bottom: parseInt(Math.round(bounds.bottom), 10) || 0,
    left: parseInt(Math.round(bounds.left), 10) || 0,
    right: parseInt(Math.round(bounds.right), 10) || 0,
    width: parseInt(Math.round(bounds.width), 10) || 0,
    height: parseInt(Math.round(bounds.height), 10) || 0
  };
}
function checkInputSupport(type, invalid_value) {
  /* Check input type support.
   *  See: https://stackoverflow.com/a/10199306/1337474
   */
  let support = false;
  const input = document.createElement("input");
  input.setAttribute("type", type);
  support = input.type == type;
  if (invalid_value !== undefined) {
    // Check for input type UI support
    input.setAttribute("value", invalid_value);
    support = input.value !== invalid_value;
  }
  return support;
}
const checkCSSFeature = (attribute, value, tag = "div") => {
  /* Check for browser support of specific CSS feature.
   */
  tag = document.createElement(tag);
  let supported = tag.style[attribute] !== undefined;
  if (supported && value !== undefined) {
    tag.style[attribute] = value;
    supported = tag.style[attribute] === value;
  }
  return supported;
};
const animation_frame = () => {
  // Return promise to await next repaint cycle
  // Use it in your async function like so: ``await utils.animation_frame()``
  // From: http://www.albertlobo.com/fractals/async-await-requestanimationframe-buddhabrot
  return new Promise(window.requestAnimationFrame);
};
const timeout = ms => {
  return new Promise(resolve => setTimeout(resolve, ms));
};

/**
 * Returns a function, that, as long as it continues to be invoked, will not
 * be triggered. The function will be called after it stops being called for
 * N milliseconds.
 * From: https://underscorejs.org/#debounce
 *
 * @param {Function} func - The function to debounce.
 * @param {Number} ms - The time in milliseconds to debounce.
 * @param {Object} timer - A module-global timer as an object.
 * @param {Boolean} [postpone=true] - If true, the function will only be called
 * at the end, after it stops being called for N milliseconds. If false, the
 * function will be called no more than each [ms] milliseconds, ensuring that
 * the function isn't postponed for for too long.
 *
 * @returns {Function} - The debounced function.
 */
const debounce = (func, ms, timer = {
  timer: null
}, postpone = true) => {
  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds.
  // From: https://underscorejs.org/#debounce
  //
  // Make sure to initialize ``debounce`` only once per to-be-debounced
  // function to not reinitialize the timer each time and debounce not being
  // able to cancel previouse runs.
  //
  // Pass a module-global timer as an object ``{ timer: null }`` if you want
  // to also cancel debounced functions from other pattern-invocations.
  timer.last_run = 0;
  return function () {
    const args = arguments;
    if (!postpone && timer.timer && Date.now() - timer.last_run <= ms) {
      return;
    }
    clearTimeout(timer.timer);
    timer.last_run = Date.now();
    timer.timer = setTimeout(() => {
      func.apply(this, args);
    }, ms);
  };
};
const isIE = () => {
  // See: https://stackoverflow.com/a/9851769/1337474
  // Internet Explorer 6-11
  return /*@cc_on!@*/ false || !!document.documentMode;
};
const jqToNode = el => {
  // Return a DOM node if a jQuery node was passed.
  if (el.jquery) {
    el = el[0];
  }
  return el;
};

/**
 * Always return an iterable object.
 *
 * @param {any} it: The object which needs to be wrapped in an array or returned as is if it is iterable.
 * @param {boolean} force_array: If the object is iterable but not an Array, convert it to an array (e.g. For jQuery items or NodeList objects).
 *
 * @returns {Array}: Returns the object wrapped in an Array, expanded to an Array or as-is if it is already iterable.
 */
const ensureArray = (it, force_array) => {
  // Ensure to return always an array
  const array_like = !!(NodeList.prototype.isPrototypeOf(it) ||
  // eslint-disable-line no-prototype-builtins
  Array.isArray(it) || it.jquery);
  return array_like ? force_array ? [...it] : it : [it];
};
const localized_isodate = date => {
  // Return a iso date (date only) in the current timezone instead of a
  // UTC ISO 8601 date+time component which toISOString returns.

  const day = date.getDate().toString().padStart(2, "0");
  const month = (date.getMonth() + 1).toString().padStart(2, "0");
  const year = date.getFullYear().toString();
  return `${year}-${month}-${day}`;
};

/**
 * Replace HTML reserved characters with html entities to add HTML for user
 * editing to e.g. a textarea or a contenteditable.
 *
 * See:
 *  https://stackoverflow.com/a/22706073/1337474
 *  https://developer.mozilla.org/en-US/docs/Glossary/Entity#reserved_characters
 *
 * @param {string} html - The HTML string to encode.
 *
 * @returns {string} - Returns the escaped html string:
 *                     ``&`` will be replaced with ``&amp;``.
 *                     ``<`` will be repalced with ``&lt;``,
 *                     ``>`` will be replaced with ``&gt;``,
 *                     ``"`` will be replaced with ``&quot;``.
 */
const escape_html = html => {
  if (!html) {
    return "";
  }
  const el = document.createElement("div");
  el.appendChild(document.createTextNode(html));
  // Return escaped html and also replace quotes.
  return el.innerHTML.replace(/"/g, "&quot;");
};

/**
 * Return unescaped, raw HTML from an escaped HTML  string.
 *
 * See:
 *  https://stackoverflow.com/a/34064434/1337474
 *  https://developer.mozilla.org/en-US/docs/Glossary/Entity#reserved_characters
 *
 * @param {string} escaped_html - The HTML string to decode.
 *
 * @returns {string} - Returns the escaped html string:
 *                     ``&amp;`` will be replaced with ``&``,
 *                     ``&lt;`` will be repalced with ``<``,
 *                     ``&gt;`` will be replaced with ``>``,
 *                     ``&quot;`` will be replaced with ``"``.
 */
const unescape_html = escaped_html => {
  if (!escaped_html) {
    return "";
  }
  const doc = new DOMParser().parseFromString(escaped_html, "text/html");
  // Return unescaped html and also unescape quote named entities.
  return doc.documentElement.textContent.replace(/&quot;/g, '"');
};

/**
 * Return true, if the given value is a valid ISO 8601 date/time string with or without an optional time component.
 *
 * @param {String} value - The date/time value to be checked.
 * @param {Boolean} [optional_time=false] - True, if time component is optional.
 * @return {Boolean} - True, if the given value is a valid Date string. False if not.
 */
const is_iso_date_time = (value, optional_time = false) => {
  const re_date_time = optional_time ? /^\d{4}-[01]\d-[0-3]\d(T[0-2]\d:[0-5]\d)?$/ : /^\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d$/;
  return re_date_time.test(value);
};

/**
 * Return true, if the given value is a valid ISO 8601 date string and without a time component.
 *
 * @param {String} value - The date value to be checked.
 * @return {Boolean} - True, if the given value is a valid ISO 8601 date string without a time component. False if not.
 */
const is_iso_date = value => {
  const re_date_time = /^\d{4}-[01]\d-[0-3]\d$/;
  return re_date_time.test(value);
};

/**
 * Return the number of days between two dates.
 * Based on: https://stackoverflow.com/a/15289883/1337474
 *
 * @param {Date} date_1 - First date to compare. We will substract date_2 from date_1.
 * @param {Date} date_2 - Second date to compare.
 * @return {Number} - The number of days between the two dates.
 */
const date_diff = (date_1, date_2) => {
  // Discard the time and time-zone information.
  const utc_1 = Date.UTC(date_1.getFullYear(), date_1.getMonth(), date_1.getDate());
  const utc_2 = Date.UTC(date_2.getFullYear(), date_2.getMonth(), date_2.getDate());
  return Math.floor((utc_1 - utc_2) / _MS_PER_DAY);
};

/**
 * Build intersection observer threshold list.
 *
 * See: https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API#building_the_array_of_threshold_ratios
 *
 * @param {Number} num_steps - The number of steps to use.
 *
 * @returns {Array} - Returns the threshold list.
 */
const threshold_list = (num_steps = 0) => {
  let thresholds = [];
  for (let i = 1.0; i <= num_steps; i++) {
    thresholds.push(i / num_steps);
  }
  thresholds.push(0);
  return thresholds.sort();
};

/**
 * is_option_truthy - Check if an Pattern option is set.
 *
 * An option is set if it is not one of:
 * - undefined
 * - null
 * - "none"
 * - ""
 *
 * @param {String} option - The option to check.
 *
 * @returns {Boolean} - Returns true if the option is set, false otherwise.
 *
 * @example
 *
 * is_option_truthy() // false
 * is_option_truthy(undefined) // false
 * is_option_truthy(null) // false
 * is_option_truthy("") // false
 * is_option_truthy("none") // false
 * is_option_truthy("false") // false
 * is_option_truthy("foo") // true
 * is_option_truthy(true) // true
 * is_option_truthy(0) // true
 *
 */
const is_option_truthy = option => {
  return ![undefined, null, "none", false, "false", ""].includes(option);
};
var utils = {
  jqueryPlugin: jqueryPlugin,
  escapeRegExp: escapeRegExp,
  isObject: isObject,
  extend: extend,
  findLabel: findLabel,
  regexp_from_wildcard: regexp_from_wildcard,
  removeWildcardClass: removeWildcardClass,
  hideOrShow: hideOrShow,
  addURLQueryParameter: addURLQueryParameter,
  removeDuplicateObjects: removeDuplicateObjects,
  mergeStack: mergeStack,
  isElementInViewport: isElementInViewport,
  hasValue: hasValue,
  parseTime: parseTime,
  parseLength: parseLength,
  findRelatives: findRelatives,
  get_bounds: get_bounds,
  checkInputSupport: checkInputSupport,
  checkCSSFeature: checkCSSFeature,
  animation_frame: animation_frame,
  timeout: timeout,
  debounce: debounce,
  isIE: isIE,
  jqToNode: jqToNode,
  ensureArray: ensureArray,
  localized_isodate: localized_isodate,
  escape_html: escape_html,
  unescape_html: unescape_html,
  is_iso_date_time: is_iso_date_time,
  is_iso_date: is_iso_date,
  date_diff: date_diff,
  threshold_list: threshold_list,
  is_option_truthy: is_option_truthy,
  //getCSSValue: dom.get_css_value, // BBB: moved to dom. TODO: Remove in upcoming version.
  elementInViewport: el => {
    // BBB: Remove with next major version.
    console.warn("Deprecated. Use utils.isElementInViewport");
    return isElementInViewport(el);
  }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (utils);

/***/ })

}]);
//# sourceMappingURL=vendors-node_modules_patternslib_patternslib_src_core_basepattern_js-node_modules_patternslib-62f24d.18e351f6ddcb1fb7f4fa.min.js.map